from typing import Any, Dict, List

import json
from jsonschema import RefResolver, Draft202012Validator

from ..wic_types import Json, Tool, Tools
from .biobb import config_schemas


def default_schema(url: bool = False) -> Json:
    """A basic default schema (to avoid copy & paste).

    Args:
        url (bool, optional): Determines whether to include the $schema url. Defaults to False.

    Returns:
        Json: A basic default schema
    """
    schema: Json = {}
    schema['type'] = 'object'
    schema['additionalProperties'] = False
    if url:
        schema['$schema'] = 'https://json-schema.org/draft/2020-12/schema'
    return schema


def cwl_tool_schema(name: str, tool: Tool) -> Json:
    """Generates a schema (including documentation) based on the inputs of a CWL CommandLineTool.

    Args:
        name (str): The name of the CWL CommandLineTool
        tool (Tool): The CWL CommandLineTool

    Returns:
        Json: An autogenerated, documented schema based on the inputs of a CWL CommandLineTool.
    """
    inputs_props: Json = {}
    #required = []
    for key, val in tool.cwl['inputs'].items():
        inputs_props[key] = {}
        # Initialize special cases
        if key == 'config':
            inputs_props[key] = config_schemas.get(name, {})

        inputs_props[key]['title'] = val.get('label', '')
        inputs_props[key]['description'] = val.get('doc', '')

        valtype = val.get('type', '')
        # Determine required keys
        #if key == 'config' or not ('?' in valtype or 'default' in val):
        #    required.append(key)

        # Add type information, with exceptions
        if isinstance(valtype, str):
            valtype = valtype.replace('?', '')
        if (not (valtype in ['', 'File']) and # Json does not have a File type
            not (key == 'config') and name in config_schemas):  # Exclude config schemas
            inputs_props[key]['type'] = valtype

    # Do not mark properties which are required for CWL as required for yml,
    # because the whole point of inference is that we shouldn't have to!
    #if not required == []:
    #    inputs_props['required'] = required

    inputs = default_schema()
    inputs['properties'] = inputs_props

    step_name = default_schema()
    step_name['properties'] = {'in': inputs}

    schema = default_schema(url=True)
    # NOTE: See comment in get_validator(). Nonetheless, the vscode YAML extension
    # appears to be resolving ids w.r.t. relative local paths. jsonschema
    # (correctly) treats f'tools/{name}.json' as as uninterpreted string,
    # so instead of using name let's just use fake relative paths in ids.
    schema['$id'] = f'tools/{name}.json'
    schema['title'] = tool.cwl.get('label', '')
    schema['description'] = tool.cwl.get('doc', '')
    schema['properties'] = {name: step_name}
    return schema


def wic_tag_schema() -> Json:
    """The schema of the (recursive) wic: metadata annotation tag.

    Returns:
        Json: The schema of the (recursive) wic: metadata annotation tag.
    """
    # NOTE: This schema needs to be recursive. Use dynamic anchors / references.
    # See https://json-schema.org/draft/2020-12/json-schema-core.html#dynamic-ref
    # and https://stackoverflow.com/questions/69728686/explanation-of-dynamicref-dynamicanchor-in-json-schema-as-opposed-to-ref-and

    graphviz_props: Json = {}
    graphviz_props['label'] = {'type': 'string'}
    graphviz_props['style'] = {'type': 'string'}
    graphviz_props['ranksame'] = {'type': 'array'}
    graphviz_props['ranksame']['items'] = {'type': 'string'}

    graphviz = default_schema()
    graphviz['properties'] = graphviz_props

    # Call recursive reference
    recursive_ref = {'$dynamicRef': '#wic'}
    in_props: Json = {} # TODO: Add yml specific properties

    scatter_props: Json = {} # TODO: Add yml specific properties

    choices = default_schema()
    choices['properties'] = {'in': in_props, 'wic': recursive_ref, 'scatter': scatter_props}

    # See https://json-schema.org/understanding-json-schema/reference/object.html#patternproperties
    # NOTE: This recursive schema is correct, as determined by jsonschema.validate()
    # However, it seems that the vscode YAML extension does not support recursive
    # schema. (IntelliSense works fine until the first instance of recursion.)
    # TODO: A workaround would be to autogenerate a specific schema for each
    # yml file. We should probably do this anyway for the in: tag.
    steps = default_schema()
    # additionalProperties = False still works with patternProperties FYI
    steps['patternProperties'] = {"\\([0-9]+, [A-Za-z0-9_\\.]+\\)": choices}

    #backends = default_schema()
    backends: Dict[Any, Any] = {}
    backends['type'] = 'object'
    backends['additionalProperties'] = True
    # TODO: Restrict the backend properties and make default_backend an enum

    namespace: Dict[Any, Any] = {}
    namespace['type'] = 'string'
    # TODO: Restrict the namespace properties to only those in yml_paths.txt

    backend = {'type': 'string'}
    default_backend = {'type': 'string'}
    inlineable = {'type': 'boolean'}

    environment_props: Json = {}
    environment_props['action'] = {'type': 'string'}
    environment_props['save_defs'] = {'type': 'array'}
    environment_props['save_defs']['items'] = {'type': 'string'}

    environment = default_schema()
    environment['properties'] = environment_props

    schema = default_schema(url=True)
    schema['$id'] = 'wic_tag'
    # Create recursive anchor
    schema['$dynamicAnchor'] = 'wic'
    schema['title'] = 'Metadata annotations'
    schema['description'] = 'Use steps: to recursively overload / pass parameters.\nUse graphviz: to modify the DAGs.'
    schema['properties'] = {'graphviz': graphviz, 'steps': steps, 'backend': backend,
                            'backends': backends, 'default_backend': default_backend,
                            'namespace': namespace, 'inlineable': inlineable, 'environment': environment}
    return schema


def wic_main_schema(tools_cwl: Tools, yml_stems: List[str]) -> Json:
    """The main schema which is used to validate yml files.

    Args:
        tools_cwl (Tools): The CWL CommandLineTool definitions found using get_tools_cwl()
        yml_stems (List[str]): The names of the yml workflow definitions found using get_yml_paths()

    Returns:
        Json: The main schema which is used to validate yml files.
    """
    # NOTE: Use oneOf to allow {}, i.e. no explicit arguments
    tools_refs: List[Json] = [{'oneOf': [{'$ref': f'tools/{step_id.stem}.json'}, {}]} for step_id in tools_cwl]
    # NOTE: See comment in get_validator(). Nonetheless, the vscode YAML extension
    # appears to be resolving ids w.r.t. relative local paths. jsonschema
    # (correctly) treats f'tools/{name}.json' as as uninterpreted string,
    # so instead of using stem let's just use fake relative paths in ids.

    empty_schema: Json = {}
    # NOTE: For now, let's just use an empty schema for each step. That way, we
    # can just use a single giant schema to validate every yml file. Although
    # this 'loses' information about subworkflows in the current yml file, we
    # validate each subworkflow yml file independently, so it should be good
    # enough to catch most errors. It also avoids some of the issues below.
    # Alternatively, after compiling a yml file to CWL, we could possibly
    # create a stronger schema using cwl_tool_schema() that would (recursively)
    # contain the exact information specific to each yml file.
    # One should be careful not to introduce a chicken-and-egg problem here:
    # The main goal of the schema is to prevent problems *before* compilation,
    # so making the schema dependent on compilation is problematic.
    # Moreover, for interactive use the stronger schema is too rigid; we don't
    # want vscode to complain the moment a user adds an additional step!
    # Where the alternative approach may be useful is to validate AST
    # transformations during the compilation process. Specifically, for every
    # AST transformation there should be a corresponding schema transformation,
    # and we could/should re-validate after every modification. This will
    # require substantial code changes, so let's not worry about it for now.
    yml_schemas: List[Json] = [{**default_schema(), 'properties': {f'{stem}.yml': empty_schema}} for stem in yml_stems]

    steps: Json = {}
    steps['type'] = 'array'
    steps['description'] = 'A list of workflow steps'
    steps['items'] = {'anyOf': tools_refs + yml_schemas, 'title': 'Valid workflow steps'}

    schema = default_schema(url=True)
    schema['$id'] = 'wic_main'
    schema['title'] = 'Validating against the Workflow Interence Compiler schema'
    #schema['description'] = ''
    #schema['required'] = ['steps']
    schema['properties'] = {'wic': wic_tag_schema(), 'steps': steps} # 'required': ['steps']

    return schema


def get_validator(tools_cwl: Tools, yml_stems: List[str], write_to_disk: bool = False) -> Draft202012Validator:
    """Generates the main schema used to check the yml files for correctness and returns a validator.

    Args:
        tools_cwl (Tools): The CWL CommandLineTool definitions found using get_tools_cwl()
        yml_stems (List[str]): The names of the yml workflow definitions found using get_yml_paths()

    Returns:
        Draft202012Validator: A validator which is used to check the yml files for correctness.
    """
    schema_store = {}
    for step_id, tool in tools_cwl.items():
        schema_tool = cwl_tool_schema(step_id.stem, tool)
        schema_store[schema_tool['$id']] = schema_tool
        if write_to_disk:
            with open(f'autogenerated/schemas/tools/{step_id.stem}.json', mode='w', encoding='utf-8') as f:
                f.write(json.dumps(schema_tool, indent=2))

    schema = wic_main_schema(tools_cwl, yml_stems)
    schema_store[schema['$id']] = schema
    schema_store['wic_tag'] = wic_tag_schema()
    if write_to_disk:
        with open('autogenerated/schemas/wic.json', mode='w', encoding='utf-8') as f:
            f.write(json.dumps(schema, indent=2))

    # See https://stackoverflow.com/questions/53968770/how-to-set-up-local-file-references-in-python-jsonschema-document
    # The $ref tag refers to URIs defined in $id tags, NOT relative paths on
    # the local filesystem! We need to create a mapping between ids and schemas
    # i.e. schema_store.
    resolver = RefResolver.from_schema(schema, store=schema_store)
    """ Use check_schema to 'first verify that the provided schema is
    itself valid, since not doing so can lead to less obvious error
    messages and fail in less obvious or consistent ways.'
    """
    # i.e. This should match 'https://json-schema.org/draft/2020-12/schema'
    Draft202012Validator.check_schema(schema)
    validator = Draft202012Validator(schema, resolver=resolver)
    return validator
